---
import LayoutIntro from "../layouts/LayoutIntro.astro";
import ContactameInline from "../components/ContactameInline.astro";
---

<LayoutIntro>
    <main>
        <canvas id="canvas"></canvas>
        <section class="scrollers" id="hero">
            <div class="container h-100">
                <div
                    class="col-md-6 d-flex flex-column justify-content-end justify-content-md-center h-100"
                >
                    <div class="overflow-hidden">
                        <h1
                            data-bs-theme="dark"
                            class="display-1 primer-titulo"
                        >
                            Juntos podemos construirlo...
                        </h1>
                        <p
                            data-bs-theme="dark"
                            class="display-5 primer-sutitulo"
                        >
                            Visión, estrategia y <b>acción</b>. Todo en un mismo
                            lugar.
                        </p>
                    </div>
                </div>
            </div>
        </section>
        <section class="scrollers" id="call-to-action">
            <div class="container h-100 pb-5">
                <div class="row justify-content-end h-100">
                    <div
                        class="col-md-8 d-flex flex-column justify-content-end justify-content-md-center h-100 text-end align-items-end"
                    >
                        <div class="overflow-hidden">
                            <h1
                                data-bs-theme="dark"
                                class="display-1 segundo-titulo"
                            >
                                Comencemos con la mejor decisión.
                            </h1>
                        </div>
                        <div
                            class="d-flex flex-column flex-md-row justify-content-end mt-4 align-items-center gap-2"
                        >
                            <div class="w-100"><ContactameInline /></div>
                            <a
                                class="boton_rgb py-3 px-4 rounded border border-secondary w-100 text-center text-white"
                                href="/overview"
                                data-bs-theme="dark"
                            >
                                Quiero saber más
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>
    <div class="webgl"></div>
    <div id="camera-info">Cargando posición de la cámara...</div>
</LayoutIntro>
<style>
    #canvas {
        background: linear-gradient(135deg, #6d5d74, #020105);
        height: 100vh;
        width: 100%;
        position: fixed;
        top: 0;
        z-index: 0;
    }
    .boton_rgb {
        background-color: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        padding: 2px;
    }
    .primer-titulo,
    .primer-sutitulo {
        transform: translateY(50vh);
    }
    .scrollers {
        height: 100svh;
        /* border-bottom: 1px solid #f00; */
        /* background-color: rgb(0, 0, 0, 1); */
    }

    .webgl {
        padding: 0;
        position: fixed;
        left: 0;
        top: 0;
        height: 100vh;
        z-index: 0;
        /* pointer-events: none; */
        line-height: 0;
    }
    #camera-info {
        position: fixed;
        top: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-family: monospace;
        z-index: 10000;
        /* display: none; */
    }
</style>

<script>
    var canvas = document.getElementById("canvas"),
        ctx = canvas.getContext("2d");

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    var stars = [], // Array that contains the stars
        FPS = 60, // Frames per second
        x = canvas.width; // Number of stars

    // Push stars to array

    for (var i = 0; i < x; i++) {
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: Math.random(),
            vx: Math.floor(Math.random() * 10) - 5,
            vy: Math.floor(Math.random() * 10) - 5,
        });
    }

    // Draw the scene

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.globalCompositeOperation = "lighter";

        for (var i = 0, x = stars.length; i < x; i++) {
            var s = stars[i];

            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.radius, 0, 2 * Math.PI);
            ctx.fill();
        }
    }

    // Update star locations

    function update() {
        for (var i = 0, x = stars.length; i < x; i++) {
            var s = stars[i];

            s.x += s.vx / FPS;
            s.y += s.vy / FPS;

            if (s.x < 0 || s.x > canvas.width) s.x = -s.x;
            if (s.y < 0 || s.y > canvas.height) s.y = -s.y;
        }
    }

    // Update and draw

    function tick() {
        draw();
        update();
        requestAnimationFrame(tick);
    }

    tick();
</script>
<script>
    import * as THREE from "three";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
    import { RGBELoader } from "three/examples/jsm/loaders/RGBELoader.js";
    import { DRACOLoader } from "three/examples/jsm/loaders/DRACOLoader.js";
    import { MeshoptDecoder } from "meshoptimizer";
    import { gsap } from "gsap";
    import { ScrollTrigger } from "gsap/ScrollTrigger";
    import { GSDevTools } from "gsap/GSDevTools";

    gsap.registerPlugin(GSDevTools);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
        32,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
    );

    const renderer = new THREE.WebGLRenderer({
        powerPreference: "high-performance",
        antialias: false, //TEMPORAL
        alpha: true,
    });
    const deviceRatio = Math.min(window.devicePixelRatio, 1);

    renderer.useLegacyLights = true;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; // Activar sombras
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Mantener el tipo de sombra
    renderer.setPixelRatio(deviceRatio);

    renderer.setSize(window.innerWidth, window.innerHeight);

    document.querySelector(".webgl").appendChild(renderer.domElement);

    const SpotLight3Arriba = new THREE.SpotLight(0x555555, 300000); // Color blanco, intensidad 1

    SpotLight3Arriba.position.z = 20;
    SpotLight3Arriba.position.y = 30;
    SpotLight3Arriba.position.x = 10;
    SpotLight3Arriba.castShadow = true;
    SpotLight3Arriba.shadow.mapSize.width = 2048;
    SpotLight3Arriba.shadow.mapSize.height = 2048;
    SpotLight3Arriba.shadow.bias = -0.0001;

    //scene.add(SpotLight3Arriba);

    //scene.add( Luz4);

    // Configurar la luz direccional para emitir sombras

    const spotLight = new THREE.SpotLight(0xffffff, 1000);
    spotLight.position.set(-15, 10, -5);
    spotLight.castShadow = true;
    spotLight.shadow.mapSize.width = 2048; // Aumentar resolución del mapa de sombras
    spotLight.shadow.mapSize.height = 2048;
    spotLight.shadow.bias = -0.0005;
    scene.add(spotLight);

    const spotLight2 = new THREE.SpotLight(0xffffff, 10000);
    spotLight2.position.set(105, -10, 5);
    spotLight2.castShadow = true;
    spotLight2.shadow.mapSize.width = 2048;
    spotLight2.shadow.mapSize.height = 2048;
    spotLight2.shadow.bias = -0.0005;
    scene.add(spotLight2);

    const directionalLightHelper = new THREE.DirectionalLightHelper(
        spotLight2,
        1,
    );
    //scene.add(directionalLightHelper);

    const helper = new THREE.CameraHelper(spotLight2.shadow.camera);
    //scene.add(helper);

    function defaultCoordenadas() {
        if (window.innerWidth > window.innerHeight) {
            // Landscape

            gsap.set(camera.position, {
                x: 236.51,
                y: 20.12,
                z: 232.04,
            });

            gsap.set(camera.rotation, {
                x: -0.09,
                y: 0.79,
                z: 0.06,
            });

            const tl = gsap.timeline();
            tl.to(camera.position, {
                x: 10.04,
                y: 19.81,
                z: -183.09,
                duration: 3,
            })
                .to(camera.position, {
                    x: -26.88,
                    y: 3.75,
                    z: -27.32,
                    duration: 1,
                })
                .to(camera.position, {
                    x: 48.37,
                    y: -5.09,
                    z: -14.06,
                    duration: 2,
                })
                .to(camera.rotation, {
                    x: 2.94,
                    y: 1.32,
                    z: -2.95,
                    duration: 1,
                });

            //Posición del cubo
            cube.position.x = 0;
            cube.position.y = -5;
            cube.position.z = 52.0;

            //Rotación del cubo
            cube.rotation.x = 0.0;
            cube.rotation.y = 0.0;
            cube.rotation.z = 0.0;
        } else {
            //Posición de la cámara
            camera.position.x = 76.85;
            camera.position.y = 1.11;
            camera.position.z = 2.05;

            //Rotación de la cámara
            camera.rotation.x = -0.5;
            camera.rotation.y = 1.54;
            camera.rotation.z = 0.5;

            //Posición del cubo
            cube.position.x = 0.0;
            cube.position.y = 0.5;
            cube.position.z = 0.0;

            //Rotación del cubo
            cube.rotation.x = 0.0;
            cube.rotation.y = 0.0;
            cube.rotation.z = 0.0;
        }
    }

    const gltfLoader = new GLTFLoader();
    MeshoptDecoder.ready.then(() => {
        gltfLoader.setMeshoptDecoder(MeshoptDecoder);
    });
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath("/draco/");
    gltfLoader.setDRACOLoader(dracoLoader);
    let clock = new THREE.Clock(); // Reloj para calcular el delta

    // CUBE
    let cube: THREE.Object3D;
    let mixer: THREE.AnimationMixer | undefined; // Declarar el mixer para las animaciones

    gltfLoader.load("/assets/Planeta.glb", (gltf: any) => {
        cube = gltf.scene;
        cube.scale.set(1, 1, 1); // Ajusta la escala del modelo
        const cubeGroup = new THREE.Group();
        cubeGroup.add(cube);
        cube.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });
        const Luz5 = new THREE.SpotLight(0xffd27f, 5000); // Color blanco, intensidad 1

        Luz5.position.set(-100, 0, -10);
        Luz5.castShadow = true;
        Luz5.shadow.mapSize.width = 2048;
        Luz5.shadow.mapSize.height = 2048;
        Luz5.shadow.bias = -0.0001;

        scene.add(Luz5);
        const directionalLightHelperLuz5 = new THREE.DirectionalLightHelper(
            Luz5,
            1,
        );
        //scene.add(directionalLightHelperLuz5);

        const helperLuz5 = new THREE.CameraHelper(Luz5.shadow.camera);
        //scene.add(helperLuz5);

        scene.add(cubeGroup);

        if (gltf.animations && gltf.animations.length > 0) {
            mixer = new THREE.AnimationMixer(cube);
            gltf.animations.forEach((clip) => {
                const action = mixer.clipAction(clip);
                action.play();
            });
            mixer.timeScale = 2; // velocidad de las animacion
        }
        defaultCoordenadas();
    });

    // Cargar el modelo ASTRONAUT.glb
    let astronaut: THREE.Object3D;
    let astronautMixer: THREE.AnimationMixer | undefined; // Declarar el mixer para las animaciones del astronauta

    gltfLoader.load("/assets/ASTRONAUT.glb", (gltf: THREE.GLTF) => {
        astronaut = gltf.scene;
        astronaut.scale.set(1.8, 1.8, 1.8); // Ajusta la escala del modelo

        astronaut.position.x = 3.0;
        astronaut.position.y = -14.1;
        astronaut.position.z = -20.0;
        //Rotación del cubo
        astronaut.rotation.x = -0.02;
        astronaut.rotation.y = 1.57;
        astronaut.rotation.z = 0.0;

        astronaut.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        scene.add(astronaut);

        // Configurar el AnimationMixer si el modelo tiene animaciones
        if (gltf.animations && gltf.animations.length > 0) {
            astronautMixer = new THREE.AnimationMixer(astronaut);
            gltf.animations.forEach((clip) => {
                const action = astronautMixer.clipAction(clip);
                action.play(); // Reproducir la animación
            });
            astronautMixer.timeScale = 0.8;
        }
    });

    // Cargar el modelo RING.glb
    let ring; // Declarar el objeto para el anillo
    let ringMixer; // Declarar el mixer para las animaciones del anillo

    gltfLoader.load("/assets/Ring.glb", (gltf) => {
        ring = gltf.scene;
        ring.scale.set(70, 70, 70); // Ajusta la escala del modelo

        // Posición inicial del anillo
        ring.position.x = 0.0;
        ring.position.y = -13.5;
        ring.position.z = 55.0;

        // Rotación inicial del anillo
        ring.rotation.x = 0.0;
        ring.rotation.y = 0;
        ring.rotation.z = 0.0;

        ring.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });
        const Luz4 = new THREE.SpotLight(0xffd27f, 50000); // Color blanco, intensidad 1

        Luz4.position.set(50, 100, 100);
        Luz4.castShadow = true;
        Luz4.shadow.mapSize.width = 2048;
        Luz4.shadow.mapSize.height = 2048;
        Luz4.shadow.bias = -0.0001;

        scene.add(Luz4);
        const directionalLightHelperLuz4 = new THREE.DirectionalLightHelper(
            Luz4,
            1,
        );
        //scene.add(directionalLightHelperLuz4);

        const helperLuz4 = new THREE.CameraHelper(Luz4.shadow.camera);
        //scene.add(helperLuz4);

        ring.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        scene.add(ring);

        // Configurar el AnimationMixer si el modelo tiene animaciones
        if (gltf.animations && gltf.animations.length > 0) {
            ringMixer = new THREE.AnimationMixer(ring);
            gltf.animations.forEach((clip) => {
                const action = ringMixer.clipAction(clip);
                action.play(); // Reproducir la animación
            });
        }
    });

    const controls = new OrbitControls(camera, renderer.domElement);

    function updateCameraInfo() {
        const cameraInfoDiv = document.getElementById("camera-info");
        cameraInfoDiv.innerHTML = `
            //Posición de la cámara <br>
            camera.position.x=${camera.position.x.toFixed(2)}<br>
			camera.position.y=${camera.position.y.toFixed(2)}<br>
			camera.position.z=${camera.position.z.toFixed(2)}<br>

            <br><br>//Rotación de la cámara <br>
            camera.rotation.x=${camera.rotation.x.toFixed(2)}<br>
			camera.rotation.y=${camera.rotation.y.toFixed(2)}<br>
			camera.rotation.z=${camera.rotation.z.toFixed(2)}<br>

            <br><br>//Posición del cubo <br>
            astronaut.position.x=${astronaut.position.x.toFixed(2)}<br>
			astronaut.position.y=${astronaut.position.y.toFixed(2)}<br>
			astronaut.position.z=${astronaut.position.z.toFixed(2)}<br>

            <br><br>//Rotación del cubo <br>
            astronaut.rotation.x=${astronaut.rotation.x.toFixed(2)}<br>
			astronaut.rotation.y=${astronaut.rotation.y.toFixed(2)}<br>
			astronaut.rotation.z=${astronaut.rotation.z.toFixed(2)}<br>
        `;
    }

    // Actualizar el mixer en el bucle de renderizado
    function render() {
        requestAnimationFrame(render);
        const delta = clock.getDelta(); // Calcular el tiempo delta

        if (mixer) {
            mixer.update(delta); // Actualizar el mixer del cubo
        }

        if (astronautMixer) {
            astronautMixer.update(delta); // Actualizar el mixer del astronauta
        }

        // Rotación infinita del cubo
        if (cube) {
            cube.rotation.y += 0.01; // Ajusta la velocidad de rotación si es necesario
        }

        controls.update();
        renderer.render(scene, camera);
    }
    render();

    // Detectar cuando comienza el arrastre
    window.addEventListener("mousedown", () => {
        updateCameraInfo();
    });

    // Detectar cuando termina el arrastre
    window.addEventListener("mouseup", () => {
        updateCameraInfo();
    });

    function handleMouseMove(event) {
        const x = (event.clientX / window.innerWidth) * 2 - 1; // Normalizar posición X
        const y = (event.clientY / window.innerHeight) * 2 - 1; // Normalizar posición Y

        astronaut.rotation.x = y * Math.PI; // Rotar en el eje X
        astronaut.rotation.y = x * Math.PI; // Rotar en el eje Y

        updateCameraInfo(); // Actualizar la información en pantalla
    }

    gsap.registerPlugin(ScrollTrigger);

    //window.addEventListener("mousemove", handleMouseMove);

    function resizeCanvas() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas(); // llamalo una vez al inicio

    //GSDevTools.create();
</script>
